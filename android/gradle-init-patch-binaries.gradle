// Gradle init script to automatically patch Android binaries for NixOS compatibility
// This script runs for every Gradle invocation and patches binaries after they're downloaded

import java.nio.file.Files
import java.nio.file.Paths

def isNixOS = System.getenv("NIX_PROFILES") != null || new File("/nix/store").exists()

if (!isNixOS) {
    return // Only run on NixOS
}

def gradleCacheDir = new File(System.getProperty("user.home"), ".gradle/caches")
def patchedMarkerExt = ".nixos-patched"

// Tools that need patching
def toolsToWatch = ["aapt2", "aapt", "zipalign"]

// Statistics tracking
def patchStats = [
    binariesFound: 0,
    binariesPatched: 0,
    binariesFailed: 0,
    binariesSkipped: 0
]

// Function to find the interpreter
def findInterpreter = {
    def interpreterPath = null
    def nixStoreDir = new File("/nix/store")
    
    if (nixStoreDir.exists()) {
        nixStoreDir.eachDir { dir ->
            if (dir.name.contains("glibc")) {
                def interpreter = new File(dir, "lib/ld-linux-x86-64.so.2")
                if (interpreter.exists()) {
                    interpreterPath = interpreter.absolutePath
                    return true // Stop searching
                }
            }
        }
    }
    
    return interpreterPath
}

// Function to patch a binary
def patchBinary = { File binary ->
    def markerFile = new File(binary.absolutePath + patchedMarkerExt)
    
    patchStats.binariesFound++
    
    if (markerFile.exists()) {
        patchStats.binariesSkipped++
        // Silent skip to reduce noise during normal builds
        return // Already patched
    }
    
    // Check if it's an ELF binary
    def process = ["file", binary.absolutePath].execute()
    process.waitFor()
    def output = process.text
    
    if (!output.contains("ELF")) {
        patchStats.binariesSkipped++
        // Silent skip for non-ELF binaries to reduce noise
        return // Not an ELF binary
    }
    
    // Silent operation - only log when patching actually happens
    
    // Use auto-patchelf if available
    def autoPatchelfCmd = ["auto-patchelf", "--paths", binary.absolutePath, "--ignore-missing=libgcc_s.so.1"]
    try {
        def autoPatchProcess = autoPatchelfCmd.execute()
        autoPatchProcess.waitFor()
        
        if (autoPatchProcess.exitValue() == 0) {
            markerFile.createNewFile()
            patchStats.binariesPatched++
            // Silent success
            return
        } else {
            // Capture error output for debugging
            def errorOutput = autoPatchProcess.err.text?.trim()
            println "[NixOS Patcher] auto-patchelf failed (exit code: ${autoPatchProcess.exitValue()})"
            if (errorOutput) {
                println "[NixOS Patcher] auto-patchelf error: ${errorOutput}"
            }
            println "[NixOS Patcher] Trying manual patching as fallback..."
            
            // Fallback to manual patchelf
            def interpreter = findInterpreter()
            if (interpreter) {
                def patchelfCmd = ["patchelf", "--set-interpreter", interpreter, binary.absolutePath]
                def patchelfProcess = patchelfCmd.execute()
                patchelfProcess.waitFor()
                
                if (patchelfProcess.exitValue() == 0) {
                    markerFile.createNewFile()
                    patchStats.binariesPatched++
                    // Silent success
                    return
                } else {
                    def patchelfError = patchelfProcess.err.text?.trim()
                    println "[NixOS Patcher] ✗ Manual patchelf failed (exit code: ${patchelfProcess.exitValue()})"
                    if (patchelfError) {
                        println "[NixOS Patcher] patchelf error: ${patchelfError}"
                    }
                }
            } else {
                println "[NixOS Patcher] ✗ Could not find glibc interpreter for manual patching"
            }
        }
    } catch (Exception e) {
        println "[NixOS Patcher] ✗ Exception during patching of ${binary.name}: ${e.class.simpleName}: ${e.message}"
        e.printStackTrace()
    }
    
    // If we get here, patching failed
    patchStats.binariesFailed++
    println "[NixOS Patcher] ✗ Failed to patch ${binary.name}"
}

// Hook into Gradle's task graph
gradle.taskGraph.whenReady { taskGraph ->
    // Scan for binaries that need patching before any task execution
    if (gradleCacheDir.exists()) {
        toolsToWatch.each { toolName ->
            gradleCacheDir.traverse(type: groovy.io.FileType.FILES, nameFilter: { it == toolName }) { file ->
                if (file.canExecute()) {
                    patchBinary(file)
                }
            }
        }
    }
}

// Also patch after dependency resolution
allprojects {
    afterEvaluate { project ->
        project.configurations.all { configuration ->
            configuration.incoming.afterResolve {
                // Give Gradle time to extract archives
                Thread.sleep(500)
                
                if (gradleCacheDir.exists()) {
                    toolsToWatch.each { toolName ->
                        gradleCacheDir.traverse(type: groovy.io.FileType.FILES, nameFilter: { it == toolName }) { file ->
                            if (file.canExecute()) {
                                patchBinary(file)
                            }
                        }
                    }
                }
            }
        }
    }
}

// Only show statistics if there were failures or new patches
gradle.buildFinished {
    if (patchStats.binariesFailed > 0) {
        println "[NixOS Patcher] ⚠️  WARNING: ${patchStats.binariesFailed} binaries failed to patch - builds may fail"
        println "[NixOS Patcher] Binaries found: ${patchStats.binariesFound}, Failed: ${patchStats.binariesFailed}"
    } else if (patchStats.binariesPatched > 0) {
        println "[NixOS Patcher] ✓ Patched ${patchStats.binariesPatched} new binaries"
    }
    // Silent operation when everything is already patched and working
}

// Silent operation - only log errors and failures