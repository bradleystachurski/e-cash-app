// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `add_relay`, `await_ecash_reissue`, `await_ecash_send`, `await_receive_lnv1`, `await_receive_lnv2`, `await_send_lnv1`, `await_send_lnv2`, `build_client`, `create_nostr_client`, `derive_federation_secret`, `get_client_database`, `get_federation_meta`, `get_multimint`, `has_federation`, `lnv1_select_gateway`, `lnv1_update_gateway_cache`, `lnv2_select_gateway`, `load_clients`, `parse_content`, `parse_federation_id`, `parse_federation_name`, `parse_invite_codes`, `parse_modules`, `parse_network`, `parse_picture`, `pay_lnv1`, `pay_lnv2`, `receive_lnv1`, `receive_lnv2`, `reissue_ecash`, `select_receive_gateway`, `send_ecash`, `transactions`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `try_from`

Future<void> initMultimint({required String path}) =>
    RustLib.instance.api.crateInitMultimint(path: path);

Future<FederationSelector> joinFederation({required String inviteCode}) =>
    RustLib.instance.api.crateJoinFederation(inviteCode: inviteCode);

Future<List<FederationSelector>> federations() =>
    RustLib.instance.api.crateFederations();

Future<BigInt> balance({required FederationId federationId}) =>
    RustLib.instance.api.crateBalance(federationId: federationId);

Future<(String, OperationId, String, String, BigInt)> receive({
  required FederationId federationId,
  required BigInt amountMsatsWithFees,
  required BigInt amountMsatsWithoutFees,
}) => RustLib.instance.api.crateReceive(
  federationId: federationId,
  amountMsatsWithFees: amountMsatsWithFees,
  amountMsatsWithoutFees: amountMsatsWithoutFees,
);

Future<(String, BigInt, BigInt, BigInt)> selectReceiveGateway({
  required FederationId federationId,
  required BigInt amountMsats,
}) => RustLib.instance.api.crateSelectReceiveGateway(
  federationId: federationId,
  amountMsats: amountMsats,
);

Future<OperationId> send({
  required FederationId federationId,
  required String invoice,
}) => RustLib.instance.api.crateSend(
  federationId: federationId,
  invoice: invoice,
);

Future<FinalSendOperationState> awaitSend({
  required FederationId federationId,
  required OperationId operationId,
}) => RustLib.instance.api.crateAwaitSend(
  federationId: federationId,
  operationId: operationId,
);

Future<FinalReceiveOperationState> awaitReceive({
  required FederationId federationId,
  required OperationId operationId,
}) => RustLib.instance.api.crateAwaitReceive(
  federationId: federationId,
  operationId: operationId,
);

Future<List<PublicFederation>> listFederationsFromNostr({
  required bool forceUpdate,
}) => RustLib.instance.api.crateListFederationsFromNostr(
  forceUpdate: forceUpdate,
);

Future<PaymentPreview> parseInvoice({required String bolt11}) =>
    RustLib.instance.api.crateParseInvoice(bolt11: bolt11);

Future<(FederationMeta, FederationSelector)> getFederationMeta({
  required String inviteCode,
}) => RustLib.instance.api.crateGetFederationMeta(inviteCode: inviteCode);

Future<List<Transaction>> transactions({
  required FederationId federationId,
  BigInt? timestamp,
  Uint8List? operationId,
}) => RustLib.instance.api.crateTransactions(
  federationId: federationId,
  timestamp: timestamp,
  operationId: operationId,
);

Future<(OperationId, String, BigInt)> sendEcash({
  required FederationId federationId,
  required BigInt amountMsats,
}) => RustLib.instance.api.crateSendEcash(
  federationId: federationId,
  amountMsats: amountMsats,
);

Future<SpendOobState> awaitEcashSend({
  required FederationId federationId,
  required OperationId operationId,
}) => RustLib.instance.api.crateAwaitEcashSend(
  federationId: federationId,
  operationId: operationId,
);

Future<OperationId> reissueEcash({
  required FederationId federationId,
  required String ecash,
}) => RustLib.instance.api.crateReissueEcash(
  federationId: federationId,
  ecash: ecash,
);

Future<ReissueExternalNotesState> awaitEcashReissue({
  required FederationId federationId,
  required OperationId operationId,
}) => RustLib.instance.api.crateAwaitEcashReissue(
  federationId: federationId,
  operationId: operationId,
);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Invoice>>
abstract class Bolt11Invoice implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ClientConfig>>
abstract class ClientConfig implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Connector>>
abstract class Connector implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FederationId>>
abstract class FederationId implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FederationSelector>>
abstract class FederationSelector implements RustOpaqueInterface {
  FederationId get federationId;

  String get federationName;

  String get inviteCode;

  String get network;

  set federationId(FederationId federationId);

  set federationName(String federationName);

  set inviteCode(String inviteCode);

  set network(String network);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FinalReceiveOperationState>>
abstract class FinalReceiveOperationState implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FinalSendOperationState>>
abstract class FinalSendOperationState implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InviteCode>>
abstract class InviteCode implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Multimint>>
abstract class Multimint implements RustOpaqueInterface {
  Future<FinalReceiveOperationState> awaitReceive({
    required FederationId federationId,
    required OperationId operationId,
  });

  Future<FinalSendOperationState> awaitSend({
    required FederationId federationId,
    required OperationId operationId,
  });

  Future<BigInt> balance({required FederationId federationId});

  Future<List<FederationSelector>> federations();

  Future<FederationSelector> joinFederation({required String invite});

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<Multimint> newInstance({required String path}) =>
      RustLib.instance.api.crateMultimintNew(path: path);

  Future<(Bolt11Invoice, OperationId)> receive({
    required FederationId federationId,
    required BigInt amountMsatsWithFees,
    required BigInt amountMsatsWithoutFees,
  });

  Future<OperationId> send({
    required FederationId federationId,
    required String invoice,
  });

  Future<void> updateFederationsFromNostr();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OperationId>>
abstract class OperationId implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicFederation>>
abstract class PublicFederation implements RustOpaqueInterface {
  String? get about;

  FederationId get federationId;

  String get federationName;

  List<String> get inviteCodes;

  List<String> get modules;

  String get network;

  String? get picture;

  set about(String? about);

  set federationId(FederationId federationId);

  set federationName(String federationName);

  set inviteCodes(List<String> inviteCodes);

  set modules(List<String> modules);

  set network(String network);

  set picture(String? picture);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ReissueExternalNotesState>>
abstract class ReissueExternalNotesState implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpendOOBState>>
abstract class SpendOobState implements RustOpaqueInterface {}

class FederationMeta {
  final String? picture;
  final String? welcome;
  final List<Guardian> guardians;

  const FederationMeta({this.picture, this.welcome, required this.guardians});

  @override
  int get hashCode => picture.hashCode ^ welcome.hashCode ^ guardians.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FederationMeta &&
          runtimeType == other.runtimeType &&
          picture == other.picture &&
          welcome == other.welcome &&
          guardians == other.guardians;
}

class Guardian {
  final String name;
  final String? version;

  const Guardian({required this.name, this.version});

  @override
  int get hashCode => name.hashCode ^ version.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Guardian &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          version == other.version;
}

class PaymentPreview {
  final BigInt amount;
  final String paymentHash;
  final String network;
  final String invoice;

  const PaymentPreview({
    required this.amount,
    required this.paymentHash,
    required this.network,
    required this.invoice,
  });

  @override
  int get hashCode =>
      amount.hashCode ^
      paymentHash.hashCode ^
      network.hashCode ^
      invoice.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PaymentPreview &&
          runtimeType == other.runtimeType &&
          amount == other.amount &&
          paymentHash == other.paymentHash &&
          network == other.network &&
          invoice == other.invoice;
}

class Transaction {
  final bool received;
  final BigInt amount;
  final String module;
  final BigInt timestamp;
  final Uint8List operationId;

  const Transaction({
    required this.received,
    required this.amount,
    required this.module,
    required this.timestamp,
    required this.operationId,
  });

  @override
  int get hashCode =>
      received.hashCode ^
      amount.hashCode ^
      module.hashCode ^
      timestamp.hashCode ^
      operationId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Transaction &&
          runtimeType == other.runtimeType &&
          received == other.received &&
          amount == other.amount &&
          module == other.module &&
          timestamp == other.timestamp &&
          operationId == other.operationId;
}
