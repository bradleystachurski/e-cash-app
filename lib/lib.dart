// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'event_bus.dart';
import 'frb_generated.dart';
import 'multimint.dart';
import 'nostr.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `create_event_bus`, `create_nostr_client`, `error_to_flutter`, `get_database`, `get_multimint`, `get_nostr_client`, `info_to_flutter`

Future<EventBusMultimintEvent> getEventBus() =>
    RustLib.instance.api.crateGetEventBus();

Future<void> createNewMultimint({required String path}) =>
    RustLib.instance.api.crateCreateNewMultimint(path: path);

Future<void> loadMultimint({required String path}) =>
    RustLib.instance.api.crateLoadMultimint(path: path);

Future<void> createMultimintFromWords({
  required String path,
  required List<String> words,
}) => RustLib.instance.api.crateCreateMultimintFromWords(
  path: path,
  words: words,
);

Future<bool> walletExists({required String path}) =>
    RustLib.instance.api.crateWalletExists(path: path);

Future<List<String>> getMnemonic() => RustLib.instance.api.crateGetMnemonic();

Future<FederationSelector> waitForRecovery({required String inviteCode}) =>
    RustLib.instance.api.crateWaitForRecovery(inviteCode: inviteCode);

Future<FederationSelector> joinFederation({
  required String inviteCode,
  required bool recover,
}) => RustLib.instance.api.crateJoinFederation(
  inviteCode: inviteCode,
  recover: recover,
);

Future<List<(FederationSelector, bool)>> federations() =>
    RustLib.instance.api.crateFederations();

Future<BigInt> balance({required FederationId federationId}) =>
    RustLib.instance.api.crateBalance(federationId: federationId);

Future<(String, OperationId, String, String, BigInt)> receive({
  required FederationId federationId,
  required BigInt amountMsatsWithFees,
  required BigInt amountMsatsWithoutFees,
  required String gateway,
  required bool isLnv2,
}) => RustLib.instance.api.crateReceive(
  federationId: federationId,
  amountMsatsWithFees: amountMsatsWithFees,
  amountMsatsWithoutFees: amountMsatsWithoutFees,
  gateway: gateway,
  isLnv2: isLnv2,
);

Future<(String, BigInt, bool)> selectReceiveGateway({
  required FederationId federationId,
  required BigInt amountMsats,
}) => RustLib.instance.api.crateSelectReceiveGateway(
  federationId: federationId,
  amountMsats: amountMsats,
);

Future<OperationId> sendLnaddress({
  required FederationId federationId,
  required BigInt amountMsats,
  required String address,
}) => RustLib.instance.api.crateSendLnaddress(
  federationId: federationId,
  amountMsats: amountMsats,
  address: address,
);

Future<OperationId> send({
  required FederationId federationId,
  required String invoice,
  required String gateway,
  required bool isLnv2,
}) => RustLib.instance.api.crateSend(
  federationId: federationId,
  invoice: invoice,
  gateway: gateway,
  isLnv2: isLnv2,
);

Future<LightningSendOutcome> awaitSend({
  required FederationId federationId,
  required OperationId operationId,
}) => RustLib.instance.api.crateAwaitSend(
  federationId: federationId,
  operationId: operationId,
);

Future<(FinalReceiveOperationState, BigInt)> awaitReceive({
  required FederationId federationId,
  required OperationId operationId,
}) => RustLib.instance.api.crateAwaitReceive(
  federationId: federationId,
  operationId: operationId,
);

Future<List<PublicFederation>> listFederationsFromNostr({
  required bool forceUpdate,
}) => RustLib.instance.api.crateListFederationsFromNostr(
  forceUpdate: forceUpdate,
);

Future<PaymentPreview> paymentPreview({
  required FederationId federationId,
  required String bolt11,
}) => RustLib.instance.api.cratePaymentPreview(
  federationId: federationId,
  bolt11: bolt11,
);

Future<FederationMeta> getFederationMeta({required String inviteCode}) =>
    RustLib.instance.api.crateGetFederationMeta(inviteCode: inviteCode);

Future<List<Transaction>> transactions({
  required FederationId federationId,
  BigInt? timestamp,
  Uint8List? operationId,
  required List<String> modules,
}) => RustLib.instance.api.crateTransactions(
  federationId: federationId,
  timestamp: timestamp,
  operationId: operationId,
  modules: modules,
);

Future<(OperationId, String, BigInt)> sendEcash({
  required FederationId federationId,
  required BigInt amountMsats,
}) => RustLib.instance.api.crateSendEcash(
  federationId: federationId,
  amountMsats: amountMsats,
);

Future<SpendOobState> awaitEcashSend({
  required FederationId federationId,
  required OperationId operationId,
}) => RustLib.instance.api.crateAwaitEcashSend(
  federationId: federationId,
  operationId: operationId,
);

Future<BigInt> parseEcash({
  required FederationId federationId,
  required String ecash,
}) => RustLib.instance.api.crateParseEcash(
  federationId: federationId,
  ecash: ecash,
);

Future<OperationId> reissueEcash({
  required FederationId federationId,
  required String ecash,
}) => RustLib.instance.api.crateReissueEcash(
  federationId: federationId,
  ecash: ecash,
);

Future<ReissueExternalNotesState> awaitEcashReissue({
  required FederationId federationId,
  required OperationId operationId,
}) => RustLib.instance.api.crateAwaitEcashReissue(
  federationId: federationId,
  operationId: operationId,
);

Future<bool> hasSeedPhraseAck() => RustLib.instance.api.crateHasSeedPhraseAck();

Future<void> ackSeedPhrase() => RustLib.instance.api.crateAckSeedPhrase();

Future<List<String>> wordList() => RustLib.instance.api.crateWordList();

Stream<DepositEventKind> subscribeDeposits({
  required FederationId federationId,
}) => RustLib.instance.api.crateSubscribeDeposits(federationId: federationId);

Future<void> monitorDepositAddress({
  required FederationId federationId,
  required String address,
}) => RustLib.instance.api.crateMonitorDepositAddress(
  federationId: federationId,
  address: address,
);

Future<String> allocateDepositAddress({required FederationId federationId}) =>
    RustLib.instance.api.crateAllocateDepositAddress(
      federationId: federationId,
    );

Future<List<(FederationSelector, NWCConnectionInfo)>> getNwcConnectionInfo() =>
    RustLib.instance.api.crateGetNwcConnectionInfo();

Future<NWCConnectionInfo> setNwcConnectionInfo({
  required FederationId federationId,
  required String relay,
}) => RustLib.instance.api.crateSetNwcConnectionInfo(
  federationId: federationId,
  relay: relay,
);

Future<List<String>> getRelays() => RustLib.instance.api.crateGetRelays();

Future<List<Utxo>> walletSummary({required String invite}) =>
    RustLib.instance.api.crateWalletSummary(invite: invite);

Stream<MultimintEvent> subscribeMultimintEvents() =>
    RustLib.instance.api.crateSubscribeMultimintEvents();

Future<String> federationIdToString({required FederationId federationId}) =>
    RustLib.instance.api.crateFederationIdToString(federationId: federationId);

Future<BigInt?> getBtcPrice() => RustLib.instance.api.crateGetBtcPrice();

Future<WithdrawFeesResponse> calculateWithdrawFees({
  required FederationId federationId,
  required String address,
  required BigInt amountSats,
}) => RustLib.instance.api.crateCalculateWithdrawFees(
  federationId: federationId,
  address: address,
  amountSats: amountSats,
);

Future<OperationId> withdrawToAddress({
  required FederationId federationId,
  required String address,
  required BigInt amountSats,
  required PegOutFees pegOutFees,
}) => RustLib.instance.api.crateWithdrawToAddress(
  federationId: federationId,
  address: address,
  amountSats: amountSats,
  pegOutFees: pegOutFees,
);

Future<String> awaitWithdraw({
  required FederationId federationId,
  required OperationId operationId,
}) => RustLib.instance.api.crateAwaitWithdraw(
  federationId: federationId,
  operationId: operationId,
);

Future<BigInt> getMaxWithdrawableAmount({
  required FederationId federationId,
  required String address,
}) => RustLib.instance.api.crateGetMaxWithdrawableAmount(
  federationId: federationId,
  address: address,
);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ClientConfig>>
abstract class ClientConfig implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Connector>>
abstract class Connector implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Database>>
abstract class Database implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FederationId>>
abstract class FederationId implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InviteCode>>
abstract class InviteCode implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PegOutFees>>
abstract class PegOutFees implements RustOpaqueInterface {}
